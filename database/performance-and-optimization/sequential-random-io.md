## HDD / SSD

- HDD(Hard Disk Drive) 원판 형태의 디스크(플래터)가 회전하면서 읽기/쓰기 헤드가 데이터를 읽거나 쓰는 방식.
- SSD(Solid State Drive) 플래터를 제거하고 NAND 플래시 메모리를 사용.

RAM과 비교하여 HDD는 10만 배, SSD는 1000배 정도로 느리다고 합니다. 순차적 I/O에 대해서는 HDD와 SSD가 비슷하거나 SSD가 약간 더 빠릅니다. 하지만, 랜덤 I/O에서 SSD가 HDD 보다 훨씬 빠릅니다.

**암달의 법칙**에 의하면, 애플리케이션 레벨에서 최적화를 한들 쿼리 성능이 좋지 않아 디스크 I/O가 많이 발생한다면 전체 시스템 성능 향상에 큰 영향을 줄 수 없다고 합니다.

![img](https://velog.velcdn.com/images/yoonuk/post/a4f83012-0acb-480c-acea-1b498778624e/image.png)







## 순차 I/O(Sequantial I/O) 와 랜덤 I/O(Random I/O)

랜덤 I/O는 **데이터를 임의의 순서로 읽거나 쓰는 방식**을 말합니다.

예를 들어, 파일의 특정 위치에 있는 데이터를 읽거나 쓰는 것이 랜덤 I/O에 해당합니다. 디스크의 헤드가 데이터가 위치한 곳으로 이동해야 하므로, 디스크의 헤드 이동 시간이 크게 작용합니다.

순차 I/O는 **연속적인 데이터를 읽거나 쓰는 방식**입니다. 예를 들어, 파일을 처음부터 끝까지 순서대로 읽는 것이 순차적 I/O에 해당합니다. 순차적 I/O는 디스크의 헤드 이동이 적기 때문에 빠른 읽기/쓰기 성능을 보입니다.

만약 100개의 데이터를 읽어야 한다면, **순차 I/O**는 1번의 시스템 콜이 발생합니다. HDD 관점에선 디스크 헤더가 1번 움직입니다. **랜덤 I/O**는 총 100번의 시스템 콜을 요청하고 디스크 헤더가 100번 움직입니다.

SSD는 디스크 없이 NAND 플래시 메모리를 활용하지만  랜덤 I/O는 순차 I/O보다 처리율(Throughput)이 떨어집니다.

- **SSD는 NAND 플래시 메모리에 물리적으로 접근하여 데이터를 읽고 쓰는 것이 아니라, 논리적인 주소를 물리적인 주소로 매핑하는 매핑 테이블을 사용합니다.**

- **SSD의 데이터의 수정/삭제가 일어날 때면 물리적인 주소를 알고 접근하여 데이터를 지우고 새로 쓰는 작업을 하는데, 여기서 랜덤 I/O 와 순차 I/O 의 성능 차이가 일어납니다.**

  - **랜덤 I/O는 논리적 주소와 물리적 주소의 매핑이 계속 바뀌게 됩니다.**

  예를 들어, 100개의 랜덤 데이터를 읽으려면, 100번의 매핑 테이블 조회 및 물리적 주소 접근이 필요하게 됩니다. 이 때문에 각각의 데이터를 찾아 읽는 데 추가적인 시간이 소요되므로, 전체적인 처리 속도가 떨어질 수 있습니다.

- 순차 I/O는 **논리적 주소가 연속적이므로, 매핑 테이블을 한 번만 조회하면 연속적인 물리적 주소를 한 번에 찾을 수 있습니다.**

예를 들어, 100의 순차적 데이터를 읽을 때는, 첫 번째 데이터의 물리적 주소를 찾은 후, 이어지는 나머지 데이터들의 물리적 주소를 순차적으로 찾아갈 수 있습니다. 이렇게 하면 논리적 주소와 물리적 주소의 매핑 작업이 한 번만 필요하므로, 처리 속도가 훨씬 빠릅니다.

랜덤 I/O와 순차 I/O 모두 파일에 쓰기를 실행하면, 반드시 동기화 (fsync, flush 작업)이 필요합니다.

그런데 순차 I/O 더라도, 파일 동기화 작업이 빈번히 발생한다면 랜덤I/O 와 같이 비효율적인 형태로 동작하게 됩니다. 그래서, 캐시 메모리가 장착된 RAID 컨트롤러를 사용해 순차 I/O를 효율적으로 처리할 수 있게 도와줍니다.

**일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적입니다. 즉 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데에 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미합니다.**

### 인덱스를 활용한 SQL 튜닝이 랜덤 IO를 순차 IO로 전환시켜주기 위한 것이라고 생각합니다!